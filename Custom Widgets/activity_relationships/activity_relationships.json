{"id":null,"name":"activity_relationships","description":"","version":"1.0.0","author":"task miner","inputSchema":[{"name":"workingHours","type":"string","description":"Don't considere working hours: 0 ; or give the number of working hours per day (ex: 10)"}],"files":{"view.html":"<!--{{data.activities}}","backend.js":"(function () {\n\n    return {\n        init: function (params) {\n            this.activities = [];\n            this.workingHours = Number(params.workingHours);\n        },\n\n        update: function (trace) {\n\n            function countWeekendDays(d0, d1, ndays){\n                var nsaturdays = Math.floor( (d0.getDay()+ndays) / 7 );\n                return 2*nsaturdays + (d0.getDay()==0) - (d1.getDay()==6);\n            }\n            function NetLeadTime(startTime, endTime, workingHours){\n                // startTime = process start time in ms (double)\n                // endTime = process end time in ms (double)\n                // workingHours = number of working hours\n                // We considere that start and end are during working hours\n                // We remove non-working hours and week-ends\n\n                var millisecondsPerDay = 24 * 60 * 60 * 1000; // Day in milliseconds\n                var millisecondsPerNonWorkingHours = (24 - workingHours) * 60 * 60 * 1000;\n\n                var d0 = new Date(startTime);\n                var d1 = new Date(endTime);\n\n                var D0 = new Date(startTime);\n                D0.setHours(0);\n\n                var D1 = new Date(endTime);\n                D1.setHours(0);\n\n                var nbCalendarDays = Math.round((D1 - D0)/millisecondsPerDay);\n                var leadTimeMs = d1 - d0;\n                if (nbCalendarDays == 0){ // done within a working day\n                  return leadTimeMs;\n                }\n;\n                // Remove number of non-working hours for each calendar day\n                // Remove number of week-end hours - non-working hours (already removed)\n                return leadTimeMs - (millisecondsPerNonWorkingHours * nbCalendarDays) - (countWeekendDays(d0, d1, nbCalendarDays) * (millisecondsPerDay-millisecondsPerNonWorkingHours));\n            }   \n\n            var events = [];\n\n            if (trace.getDiscarded == 1) {\n                return;\n            }\n\n            for (var k = 0; k < trace.size(); k++) {\n                var event = trace.get(k);\n                events.push({ name: event.getEventClass(), start: event.getStartTime(), end: event.getEndTime(), predecessor: 0, successor: 0 });\n            }\n\n            // Sort the events by starttime\n            events.sort(function (a, b) { return a.start - b.start });\n\n            // For each activity, the successor is an activity that starts after and end time of the current activity\n            for (var i = 0; i < events.length; i++) {\n                for (var j = i + 1; j < events.length; j++) {\n                    if (events[i].end <= events[j].start) {\n                        events[i].successor = events[j];\n                        events[j].predecessor = events[i];\n                        //console.log(events[i].name + ' successor is ' + events[i].successor.name);\n                        break;\n                    }\n                }\n            }\n            // for all activities with no predecessor, search events with a starttime and endtime before the starttime of the event\n            for (var i = events.length - 1; i > 0; i--) {\n                if (events[i].predecessor)\n                    break;\n                for (var j = i - 1; j >= 0; j--) {\n                    if (events[i].end < events[j].start) {\n                        events[i].successor = events[j];\n                        events[j].predecessor = events[i];\n                        break;\n                    }\n                }\n            }\n            /* ACTIVITIES IS A GLOBAL VARIABLE THAT HOLDS ALL THE DATA WE NEED FOR EACH ACTIVITY\n                this.activities = [{\n                    'activity': \"activity1\",\n                    'count': 134,\n                    successors: [{ 'activity': \"activity2\", 'count': 120, 'pathtime_sum': 123434 },\n                    { activity: \"activity3\", count: 120, pathtime_sum: 123434 }],\n                    predecessors: [{ activity: \"activity2\", count: 120, pathtime_sum: 123434 },\n                    { activity: \"activity2\", count: 120, pathtime_sum: 123434 }]\n                },\n                {\n                    'activity': \"activity2\",\n                    'count': 134,\n                    successors: [{ 'activity': \"activity2\", 'count': 120, 'pathtime_sum': 123434 },\n                    { activity: \"activity3\", count: 120, pathtime_sum: 123434 }],\n                    predecessors: [{ activity: \"activity2\", count: 120, pathtime_sum: 123434 },\n                    { activity: \"activity2\", count: 120, pathtime_sum: 123434 }]\n                }]\n            */\n            // Update the activities global variable for all the events\n            for (var i = 0; i < events.length; i++) {\n                var current_event = events[i];\n                var index = -1;\n                for (var j = 0; j < this.activities.length; j++) {\n                    if (this.activities[j].activity == current_event.name) {\n                        index = j;\n                        break;\n                    }\n                }\n                if (index < 0) {\n                    // create a new entry for the current event\n                    index = this.activities.push({ activity: current_event.name, count: 0, predecessors: [], successors: [] }) - 1;\n                }\n                // update this.activities array\n                var current_activity = this.activities[index];\n                current_activity.count++;\n                //console.log(current_activity.count);\n                if (current_event.predecessor) {\n                    //console.log(current_event.name + ' add predecessor ' + current_event.predecessor.name);\n                    // find the predecessor activity in the predecessor list\n                    var pred_index = -1;\n                    for (var j = 0; j < current_activity.predecessors.length; j++) {\n                        if (current_activity.predecessors[j].activity == current_event.predecessor.name) {\n                            pred_index = j;\n                            break;\n                        }\n                    }\n                    if (pred_index < 0) { // create a new entry in the predecessor list\n                        pred_index = current_activity.predecessors.push({ activity: current_event.predecessor.name, count: 0, pathtime_sum: 0, pathtime_avg:0 }) - 1; // we need the index not the size\n                    }\n                    // update the predecessor pred_index\n                    current_activity.predecessors[pred_index].count += 1;\n                    //just keep working hours/days\n                    if (this.workingHours)\n                        current_activity.predecessors[pred_index].pathtime_sum += NetLeadTime(current_event.predecessor.end, current_event.start, 8) ;\n                    else\n                        current_activity.predecessors[pred_index].pathtime_sum += current_event.start - current_event.predecessor.end;\n\n                }\n                //console.log(current_activity.count);\n                if (current_event.successor) {\n                    // find the successor activity in the successor list\n                    var succ_index = -1;\n                    for (var j = 0; j < current_activity.successors.length; j++) {\n                        if (current_activity.successors[j].activity == current_event.successor.name) {\n                            succ_index = j;\n                            break;\n                        }\n                    }\n                    if (succ_index < 0) { // create a new entry in the predecessor list\n                        succ_index = current_activity.successors.push({ activity: current_event.successor.name, count: 0, pathtime_sum: 0, pathtime_avg:0  }) - 1; // we need the index not the size\n                    }\n                    // update the predecessor pred_index\n                    current_activity.successors[succ_index].count += 1;\n                    if (this.workingHours)\n                        current_activity.successors[succ_index].pathtime_sum += NetLeadTime(current_event.end, current_event.successor.start, 8);   \n                    else \n                        current_activity.successors[succ_index].pathtime_sum +=  current_event.successor.start - current_event.end;\n\n                }\n                //console.log(current_activity.count);\n            }\n        },\n\n        finalize: function (output) {\n\n            // sort by frequency\n            this.activities.sort(function (a, b) { return b.count - a.count });\n            // compute average pathtime\n            for (var i = 0; i < this.activities.length; i++){\n                var current_activity = this.activities[i];\n                for (var j = 0; j < current_activity.predecessors.length; j++){\n                    if (current_activity.predecessors[j].pathtime_sum)\n                        current_activity.predecessors[j].pathtime_avg = current_activity.predecessors[j].pathtime_sum / current_activity.predecessors[j].count;\n                }\n                for (var j = 0; j < current_activity.successors.length; j++){\n                    if (current_activity.successors[j].pathtime_sum)\n                        current_activity.successors[j].pathtime_avg = current_activity.successors[j].pathtime_sum / current_activity.successors[j].count;\n                }\n            }\n            output.activities = this.activities;\n        }\n    };\n})();\n\n","frontend.js":"return {\n    init: function (context) {\n\n    },\n\n    update: function (data, context) {\n\n        const formatDuration = ms => {\n            if (ms < 0) ms = -ms;\n            const time = {\n              day: Math.floor(ms / 86400000),\n              hour: Math.floor(ms / 3600000) % 24,\n              minute: Math.floor(ms / 60000) % 60,\n              second: Math.floor(ms / 1000) % 60,\n              millisecond: Math.floor(ms) % 1000\n            };\n            if (time.day == 0)\n                if (time.hour == 0)\n                    if (time.minute == 0)\n                        if (time.second == 0)\n                            if (time.millisecond == 0) return (0);\n                            else return (time.second +'.'+time.millisecond+ ' s');\n                        else\n                            return (time.second +'.'+time.millisecond+ ' s');\n                    else return (time.minute + ' m ' + time.second + ' s');\n                else return (time.hour + ' h ' + time.minute + ' m');\n            else return (time.day + ' d ' + time.hour + ' h ' + time.minute + ' m');\n          };\n        \n        function createTableFromObjects(data, text) {\n            const table = document.createElement('table');\n            var headerRow = document.createElement('tr');\n\n            // Create table header row\n            var headerCell = document.createElement('th');\n            headerCell.textContent = text;\n            headerRow.appendChild(headerCell);\n            headerCell = document.createElement('th');\n            headerCell.textContent = 'Frequency';\n\n            headerRow.appendChild(headerCell);\n            headerCell = document.createElement('th');\n            headerCell.textContent = 'Avg Pathtime';\n\n            headerRow.appendChild(headerCell);\n\n            table.appendChild(headerRow);\n\n            // Create table data rows\n            for (const obj of data) {\n                var dataRow = document.createElement('tr');\n                dataRow.classList.add(\"table-row\");\n                var dataCell = document.createElement('td');\n                dataCell.textContent = obj.activity;\n                dataRow.appendChild(dataCell);\n                dataCell = document.createElement('td');\n                dataCell.textContent = obj.count;\n                dataRow.appendChild(dataCell);\n                dataCell = document.createElement('td');\n                dataCell.textContent = formatDuration(obj.pathtime_avg);\n                dataRow.appendChild(dataCell);\n                table.appendChild(dataRow);\n            }\n\n            return table;\n        };\n\n        context.scope.data = data;\n\n        var widget = document.getElementById(context.scope.widgetId);\n        var widget_first_div = widget.getElementsByTagName('div')[0];\n        var tableContainer;\n        var table;\n        var row;\n        var cell;\n\n        for (var i = 0; i < data.activities.length; i++) {\n            var current_activity = data.activities[i];\n            tableContainer = document.createElement('div');\n            tableContainer.id = 'div_' + i;\n            tableContainer.classList.add('table-wrapper');\n            widget_first_div.appendChild(tableContainer);\n            table = document.createElement('table');\n            row = document.createElement('tr');\n            table.appendChild(row);\n            cell = document.createElement('th');\n            cell.classList.add(\"table-headings\");\n            cell.textContent = current_activity.activity;\n            row.appendChild(cell);\n            cell = document.createElement('th');\n            cell.classList.add(\"table-headings\");\n            cell.textContent = 'Frequency: '+current_activity.count;\n            row.appendChild(cell);\n\n            tableContainer.appendChild(table);\n            // table for next activities of each activity\n            if (current_activity.predecessors.length > 0) {\n                var predecessors = current_activity.predecessors;\n                predecessors = predecessors.sort((a, b) => {\n                   return b.count - a.count;\n                });\n                \n                table = createTableFromObjects(predecessors,'Predecessors');\n                tableContainer.appendChild(table);\n                tableContainer.appendChild(document.createElement('p'));\n            }\n            if (current_activity.successors.length > 0) {\n                var successors = current_activity.successors;\n                successors = successors.sort((a, b) => {\n                    return b.count - a.count;\n                  });\n                table = createTableFromObjects(successors, 'Successors');\n                tableContainer.appendChild(table);\n\n            }\n        }\n\n\n    },\n\n    resize: function (size, context) {\n\n    }\n};","style.css":"*{\n\tcolor:#333;\n}\n.table-wrapper {\n    margin: 1rem;\n    box-shadow: 0px 0px 6px -2px rgb(0 50 72 / 14%);\n    border: 1px solid #dae4ee;\n\toverflow: hidden;\n  \ttext-align: right;\n}\n\ntable {\n    width: 100%;\n}\n\n.table-row:nth-child(odd) {\n    background: #F3F3F3;\n}\n\n.table-row:nth-child(odd):hover {\n    background: #CCE5E9;\n}\n\n.table-row:nth-child(even) {\n    background: #fbfdff;\n}\n\n.table-row:nth-child(even):hover {\n    background: #CCE5E9;\n}\n\n.table-row .table-cell:not(:last-child) {\n    border-right: 1px solid #DAE4EE;\n}\n\n.table-cell{\n    padding: 0.5rem;\n}\n\n.table-headings{\n    background: #F3F3F3;\n\n  color:#222b45;\n  line-height:1.5;\n  text-align: left;\n  font-size:1rem;\n  padding: 0.5rem;\n  border-bottom: 1px solid #DAE4EE;\n}\n\n.table-headings:not(:last-child) {\n    border-right: 1px solid #DAE4EE;\n}"}}
