{"id":null,"name":"quartiles","description":"","version":"1.0.0","author":"task miner","inputSchema":[{"name":"DIMENSION","type":"dimension","description":"select a dimension or custom metric (only numeric/integer/duration)"},{"name":"TYPE","type":"string","description":"INTEGER, NUMERIC, or DURATION"},{"name":"KEEP_EMPTY_VALUES","type":"string","description":"y or n"},{"name":"ACTIVITY","type":"string","description":"The activity that holds the value. You can keep it empty if this is the first one"}],"files":{"view.html":"<div>\ndimension: {{data.DIMENSION}} <br>\ntype: {{data.TYPE}}<br>\nactivity: {{data.ACTIVITY}}<br>\nlength: {{data.LEN}} <br>\nmin: {{data.MIN}} <br>\nmax: {{data.MAX}} <br>\nQ1 : {{data.Q1}} <br>\nMEDIAN : {{data.MEDIAN}} <br>\nQ3 : {{data.Q3}} <br>\nIQR = {{data.IQR}} <br>\n\n1rst decile = {{data.DECILE_1}} <br>\n9th decile = {{data.DECILE_9}}<br>\n</div>","backend.js":"(function(){\n\n    function getMedianIndexes(a, b){\n        // a and b are indexes in an array\n        var len = b - a + 1;\n        if (len % 2)\n            // odd number of values\n            return [a + (len - 1)/2 , a + (len + 1)/2];\n        else\n            // even number of values\n            return [a + len/2 - 1, a + len/2];\n    }\n\n    function filterAndComputeMetrics(trace) {\n        // Use this metrics variable for your own metrics (add more if needed)\n        var metrics = {\n            'exclude': 0,\n            'value': 0,            \n            'leadtime': 0\n        };\n\n        var firstevent = trace.get(0).getStartTime();\n        var lastevent = firstevent;\n        if (this.CUSTOMMETRIC) {\n            metrics.value = API.getCustomMetricValue(this.DIMENSION, trace);\n            if (metrics.value == null) {\n                metrics.exclude = 1;\n                return metrics;\n            }\n            console.log(metrics.value)\n\n        }\n        // Compute the leadtime, get the starttime of ACTIVITY, get DIMENSION value\n        for (var k = 0; k < trace.size(); k++) {\n            var event = trace.get(k);\n            // needed to compute the leadtime\n            if (event.getStartTime() < firstevent) {\n                firstevent = event.getStartTime();\n            }\n            else if (event.getStartTime() > lastevent)\n                lastevent = event.getStartTime();\n\n            // select the start time we want to use for the trend\n            // in case of DIMENSION, get the value from a specific ACTIVITY \n            // if ACTIVITY=='PROCESS' we take the starttime of the process\n            if ((this.ACTIVITY == 'PROCESS') && (k==0)) {\n                metrics.eventTime = event.getStartTime();\n                if (this.TYPE == 'INTEGER') // get the DIMENSION value from the first event\n                    metrics.value = event.getIntCustomAttributeValue(this.DIMENSION);\n                else metrics.value = event.getDoubleCustomAttributeValue(this.DIMENSION);\n            }\n            else if (event.getEventClass() == this.ACTIVITY) {\n                metrics.eventTime = event.getStartTime();\n                if (this.TYPE == 'INTEGER') // get the DIMENSION value from the first event\n                    metrics.value = event.getIntCustomAttributeValue(this.DIMENSION);\n                else metrics.value = event.getDoubleCustomAttributeValue(this.DIMENSION);\n            }\n        }\n        if (metrics.value == '') {\n            if (this.KEEP_EMPTY_VALUES[0] == 'n') { // exclude cases with no value for DIMENSION\n                metrics.exclude = 1;\n            }\n            else { // keep the case and replace the value with None\n                metrics.value = \"None\";\n            }\n        }\n        metrics.leadtime = lastevent - firstevent;\n        if (metrics.eventTime == 0) metrics.exclude = 1; // ACTIVITY NOT FOUND\n        return metrics;\n    }\n\n    return {\n        init: function(params) {\n            this.DIMENSION = params.DIMENSION;\n            var typeChoices = ['DURATION','NUMERIC','INTEGER']\n            if (params.TYPE.indexOf(typeChoices) < 0)\n                this.TYPE =  'NUMERIC'; // default\n            // if DIMENSION is a custom metric remove attr-custom-metrics from the name\n            if (this.DIMENSION.contains('attr-custom-metrics')){\n                this.DIMENSION = this.DIMENSION.replace('attr-custom-metrics','');\n                this.CUSTOMMETRIC = 1; // custom metric\n            }\n            else // standard dimension\n            {                \n                this.DIMENSION = this.DIMENSION.replace('attr-custom-', '');\n                this.CUSTOMMETRIC = 0; // standard dimension\n            }\n            this.ACTIVITY = params.ACTIVITY; // the activity in which we find the value of the dimension and from which we take the timestamp\n            if (this.ACTIVITY == '') this.ACTIVITY = 'PROCESS';\n            this.KEEP_EMPTY_VALUES = params.KEEP_EMPTY_VALUES; // \"yes\"=keep cases when value=='', \"no\"= exclude these cases\n            if (this.KEEP_EMPTY_VALUES == '') this.KEEP_EMPTY_VALUES= 'no';\n            else if (this.KEEP_EMPTY_VALUES[0] == 'y') this.KEEP_EMPTY_VALUES = 'yes';\n            else this.KEEP_EMPTY_VALUES = 'no';\n            this.dataset = [];\n        },\n    \n        update: function(trace) {\n    \n            if(trace.getDiscarded == 1) {\n                return;\n            }\n\n            var metrics = filterAndComputeMetrics(trace);\n            if (metrics.exclude) return;\n\n            this.dataset.push(metrics.value);\n            return;\n        },\n        \n        finalize: function(output) {\n            var n = this.dataset.length;\n            output.LEN = n;\n            // sort the array\n            this.dataset.sort(function(a, b){ return a - b});\n\n            output.MIN = this.dataset[0];\n            output.MAX = this.dataset[n - 1];\n\n            // Median\n            // For sets with an odd number of members, n is odd:\n            // Median = value of the ((n+1)/2)th item in the sorted set\n            // For sets with an even number of members, n is even:\n            // Median = value of the [(n/2)th item + (n/2 + 1)th item] / 2 in the sorted set\n            // If the size of the data set is odd, do not include the median when finding the first and third quartiles.\n\n            n = this.dataset.length;\n            if (n % 2){ \n                //odd number of data\n                //odd: 0 1 2 q1=3 4 5 6 m=7 8 9 10 q3=11 12 13 14 \n                //odd: 0 1 2 avg(3, 4) 5 6 7 m=8 9 10 11 avg(12, 13) 14 15 16\n                var m = (n-1)/2;\n                output.MEDIAN = this.dataset[m];\n                // exclude the median to compute Q1 and Q3\n                var r = getMedianIndexes(0, m-1);\n                output.Q1 = (this.dataset[r[0]] + this.dataset[r[1]]) / 2;\n                r = getMedianIndexes(m+1, n);\n                output.Q3 = (this.dataset[r[0]] + this.dataset[r[1]]) / 2;\n            }\n            else{\n                // m = 5\n                // even: 0 1 avg(2, 3) 4 avg(5, 6) 7 avg(8, 9) 10 11 \n                // even: 0 1 2 q1=3 4 5 avg(6, 7) 8 9 q3=10 11 12 13\n                var m = n/2 - 1;\n                output.MEDIAN = (this.dataset[m] + this.dataset[m+1]) / 2;\n                var r = getMedianIndexes(0, m);\n                output.Q1 = (this.dataset[r[0]] + this.dataset[r[1]]) / 2;\n                r = getMedianIndexes(m+1, n);\n                output.Q3 = (this.dataset[r[0]] + this.dataset[r[1]]) / 2;\n            }\n\n            output.IQR = output.Q3 - output.Q1;\n            output.LOW_OUTLIER = output.Q1 - 1.5*output.IQR;\n            output.HIGH_OUTLIER = output.Q3 + 1.5*output.IQR;\n            output.DECILE_1 = this.dataset[Math.floor(output.LEN / 10)];\n            output.DECILE_9 = this.dataset[Math.floor(output.LEN * 9/10)]\n            output.DIMENSION = this.DIMENSION;\n            output.TYPE = this.TYPE;\n            output.CUSTOMMETRIC =  this.CUSTOMMETRIC;\n            output.ACTIVITY = this.ACTIVITY;\n            console.log(this.dataset)\n        }\n    };})();\n\n","frontend.js":"return {\n\n\t\n\tinit: function(context){\n\t\tvar widget = document.getElementById(context.scope.widgetId);\n\t\tvar div = document.createElement('div');\n\t\tdiv.id = context.scope.widgetId + '_div'; // creates a unique div id\n\t\twidget.appendChild(div);\n\t\techarts.init(div);\n\t},\n\n\tupdate: function(data, context){\n\n\n\t\tconst formatDuration = ms => {\n\t\t\tif (ms < 0) {\n\t\t\t\tms = 0;\n\t\t\t}\n\t\t\tconst time = {\n\t\t\t  d: Math.floor(ms / 86400000),\n\t\t\t  h: Math.floor(ms / 3600000) % 24,\n\t\t\t  m: Math.floor(ms / 60000) % 60,\n\t\t\t  s: Math.floor(ms / 1000) % 60,\n\t\t\t  ms: Math.floor(ms) % 1000\n\t\t\t};\n\t\t\treturn Object.entries(time)\n\t\t\t  .filter(val => val[1] !== 0)\n\t\t\t  .map(([key, val]) => `${val} ${key}${val !== 1 ? '' : ''}`)\n\t\t\t  .join(', ');\n\t\t  };\n\n        context.scope.data = data;\n\t\t// transform the displayed value if data.TYPE = 1 (duration)\n\t\tif (data.TYPE == 'DURATION'){\n\t\t\t// duration\n\t\t\tdata.MIN = formatDuration(data.MIN);\n\t\t\tdata.MAX = formatDuration(data.MAX);\n\t\t\tdata.Q1 = formatDuration(data.Q1);\n\t\t\tdata.MEDIAN = formatDuration(data.MEDIAN);\n\t\t\tdata.Q3 = formatDuration(data.Q3);\n\t\t\tdata.IQR = formatDuration(data.IQR);\n\t\t\tdata.LOW_OUTLIER = formatDuration(data.LOW_OUTLIER);\n\t\t\tdata.HIGH_OUTLIER = formatDuration(data.HIGH_OUTLIER);\n\t\t\tdata.DECILE_1 = formatDuration(data.DECILE_1);\n\t\t\tdata.DECILE_9 = formatDuration(data.DECILE_9);\n\n\t\t}\n\n\t},\n\n\tresize: function(size, context){\n  \n\t}\n};","style.css":"*{\n\tcolor:#333;\n}"}}
