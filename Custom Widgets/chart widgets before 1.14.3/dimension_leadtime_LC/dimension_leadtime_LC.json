{"id":null,"name":"dimension_leadtime_LC","description":"","version":"1.0.0","author":"Patrick Megard","inputSchema":[{"name":"DIMENSION","type":"dimension","description":null},{"name":"GROUPBY","type":"string","description":"GROUPBY: day, week, month, year"},{"name":"ACTIVITY","type":"string","description":"Activity that holds the value of the dimension"},{"name":"KEEP_EMPTY_VALUES","type":"string","description":"KEEP_EMPTY_VALUES: y or n"},{"name":"MAX_NUMBER_OF_VALUES_DISPLAYED","type":"string","description":"MAX_NUMBER_OF_VALUES_DISPLAYED: max = 50"},{"name":"TIME_LABEL_UNIT","type":"string","description":"TIME_LABEL_UNIT: day, month, year"}],"files":{"view.html":"","backend.js":"(function () {\n\n    function filterAndComputeMetrics(trace) {\n        // Use this metrics variable for your own metrics (add more if needed)\n        var metrics = {\n            'exclude': 0,\n            'value': 0,\n            'eventTime': 0,\n            'leadtime': 0\n        };\n        var firstevent = trace.get(0).getStartTime();\n        var lastevent = firstevent;\n        for (var k = 0; k < trace.size(); k++) {\n            var event = trace.get(k);\n            if (event.getStartTime() < firstevent) {\n                firstevent = event.getStartTime();\n            }\n            else if (event.getStartTime() > lastevent)\n                lastevent = event.getStartTime();\n\n            if (event.getEventClass() == ACTIVITY) { // don't break if found, we need parse all the events for the leadtime\n                metrics.value = event.getStringCustomAttributeValue(DIMENSION);\n                if (metrics.value == '') {\n                    if (KEEP_EMPTY_VALUES[0] == 'n') { // exclude cases with no value for DIMENSION\n                        metrics.exclude = 1;\n                    }\n                    else { // keep the case and replace the value with None\n                        metrics.value = \"None\";\n                    }\n                }\n                metrics.eventTime = event.getStartTime();\n            }\n        }\n        metrics.leadtime = lastevent - firstevent;\n        if (metrics.eventTime == 0) metrics.exclude = 1; // ACTIVITY NOT FOUND\n        return metrics;\n    }\n\n    function computeScale(groupBy, aDate) {\n        // Update timeScale array, and push new counters to each dataset value\n\n        var newtimeScale = [];\n        var appendCounters = [];\n        aDate.setHours(0, 0, 0, 0);\n        switch (groupBy) {\n            case \"week\": aDate.setDate(aDate.getDate() - aDate.getDay()); break;\n            case \"month\": aDate.setMonth(aDate.getMonth(), 1); break;\n            case \"year\": aDate.setFullYear(aDate.getFullYear(), 0, 1); break;\n        }\n        var eventTime = aDate.getTime();\n\n        if (timeScale.length == 0) { // first event\n            timeScale.push(eventTime);\n        }\n        else if (eventTime < timeScale[0]) { // create new dates array and concat it with previous, until earliestTimePrevious\n            aDate.setTime(eventTime);\n            while (aDate.getTime() < timeScale[0]) {\n                newtimeScale.push(aDate.getTime());\n                switch (groupBy) {\n                    case \"day\": aDate.setDate(aDate.getDate() + 1); break;\n                    case \"week\": aDate.setDate(aDate.getDate() + 7); break;\n                    case \"month\": aDate.setMonth(aDate.getMonth() + 1); break;\n                    case \"year\": aDate.setFullYear(aDate.getFullYear() + 1); break;\n                }\n                appendCounters.push(0);\n            }\n            timeScale = newtimeScale.concat(timeScale);\n            for (k = 0; k < dataset.length; k++) {\n                dataset[k].counters = appendCounters.concat(dataset[k].counters);\n                dataset[k].leadtime_sums = appendCounters.concat(dataset[k].leadtime_sums);\n            }\n        }\n        else if (eventTime > timeScale[timeScale.length - 1]) { // last time was the latest, eventTime is later: add days\n            aDate.setTime(timeScale[timeScale.length - 1]);\n            while (aDate.getTime() < eventTime) {\n                switch (groupBy) {\n                    case \"day\": aDate.setDate(aDate.getDate() + 1); break;\n                    case \"week\": aDate.setDate(aDate.getDate() + 7); break;\n                    case \"month\": aDate.setMonth(aDate.getMonth() + 1); break;\n                    case \"year\": aDate.setFullYear(aDate.getFullYear() + 1); break;\n                }\n                timeScale.push(aDate.getTime());\n                for (k = 0; k < dataset.length; k++) {\n                    dataset[k].counters.push(0); // add 0 for each new date, to each counter array\n                    dataset[k].leadtime_sums.push(0); // add 0 for each new date, to each counter array\n                }\n            }\n        }\n        return eventTime;\n    }\n\n    return {\n        init: function (params) {\n            var groupByChoices = ['day', 'week', 'month', 'year'];\n\n            DIMENSION = params.DIMENSION.replace('attr-custom-', '');\n            GROUPBY = params.GROUPBY;\n            var groupByIndex = groupByChoices.indexOf(GROUPBY);\n            if (groupByIndex < 0)\n                GROUPBY = 'month';\n            TIME_LABEL_UNIT = params.TIME_LABEL_UNIT;\n            var time_label_unit_index = groupByChoices.indexOf(TIME_LABEL_UNIT);\n            if (time_label_unit_index < 0)\n                TIME_LABEL_UNIT = 'month';\n            if (time_label_unit_index < groupByIndex)\n                TIME_LABEL_UNIT = groupByChoices[groupByIndex];\n\n            ACTIVITY = params.ACTIVITY; // the activity in which we find the value of the dimension\n            KEEP_EMPTY_VALUES = params.KEEP_EMPTY_VALUES; // \"yes\"=keep cases when value=='', \"no\"= exclude these cases\n\n            MAX_NUMBER_OF_VALUES_DISPLAYED = params.MAX_NUMBER_OF_VALUES_DISPLAYED; // show top N values (max is hardcoded at 50)\n            if (MAX_NUMBER_OF_VALUES_DISPLAYED == '')\n                MAX_NUMBER_OF_VALUES_DISPLAYED = 50;\n            else\n                MAX_NUMBER_OF_VALUES_DISPLAYED = Math.min(50, Number(MAX_NUMBER_OF_VALUES_DISPLAYED));\n\n            timeScale = [];\n            dataset = [];\n        },\n\n        update: function (trace) {\n\n            if (trace.getDiscarded == 1) {\n                return;\n            }\n\n            var metrics = filterAndComputeMetrics(trace);\n            if (metrics.exclude)\n                return;\n\n            eventTime = computeScale(GROUPBY, new Date(metrics.eventTime));\n\n            if (dataset.length == 0) { // first event\n                dataset.push({\n                    'value': metrics.value,\n                    'counters': [1],\n                    'leadtime_sums': [metrics.leadtime]\n                });\n                return;\n            }\n\n            // search the index of 'value' in the dataset array\n            var valueindex = -1;\n            for (var k = 0; k < dataset.length; k++) {\n                if (dataset[k].value == metrics.value) {\n                    valueindex = k;\n                    break;\n                }\n            }\n            if (valueindex < 0) {// value not yet added; add it to dataset\n                valueindex = dataset.push({\n                    'value': metrics.value,\n                    'counters': [],\n                    'leadtime_sums': []\n                }) - 1;\n                // update counters\n                for (var ii = 0; ii < dataset[0].counters.length; ii++) {\n                    dataset[valueindex].counters.push(0);\n                    dataset[valueindex].leadtime_sums.push(0);\n                }\n            }\n\n            // update the counters\n            dataset[valueindex].counters[timeScale.indexOf(eventTime)]++;\n            dataset[valueindex].leadtime_sums[timeScale.indexOf(eventTime)] += metrics.leadtime;\n        },\n\n        finalize: function (output) {\n            output.DIMENSION = DIMENSION;\n            output.GROUPBY = GROUPBY;\n            output.TIME_LABEL_UNIT = TIME_LABEL_UNIT;\n            output.MAX_NUMBER_OF_VALUES_DISPLAYED = MAX_NUMBER_OF_VALUES_DISPLAYED;\n            output.ACTIVITY = ACTIVITY;\n            output.timeScale = timeScale;\n            output.dataset = dataset;\n        }\n    };\n})();\n\n","frontend.js":"return {\n\n  init: function (context) {\n    var widget = document.getElementById(context.scope.widgetId);\n    var div = document.createElement('div');\n    div.id = context.scope.widgetId + '_div'; // creates a unique div id\n    widget.appendChild(div);\n    echarts.init(div);\n  },\n\n  update: function (data, context) {\n\n    function tooltipFormatter(params) {\n      // see what params looks like in the console. It is an array, one entry per linechart. The dataset is the same in each array params[i].data\n      // console.log(params);\n      var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];\n      var aDate = new Date(parseInt(params[0].axisValue));\n      var tooltip;\n      switch (context.scope.data.GROUPBY){\n        case 'day': tooltip = aDate.toDateString() + '<br />'; break;\n        case 'week': tooltip = 'Week ' + aDate.toDateString() + '<br />'; break;\n        case 'month': tooltip = aDate.getFullYear().toString() + '-' + months[aDate.getUTCMonth()]+ '<br />'; break;\n        case 'year': tooltip = aDate.getFullYear().toString()+ '<br />'; break;\n      }\n      //tooltip = params[0].axisValueLabel;\n      var dataset = params[0].data;\n      // data[0] is the timestamp, marker is different in each params[i]\n      for (var i = 1; i < dataset.length; i++)\n        tooltip += params[i - 1].marker + ' ' + dataset[i].toFixed(1) + ' days <br />';\n      return (tooltip);\n    };\n\n    context.scope.data = data;\n    // compute leadtime average \n    var aDay = 24 * 60 * 60 * 1000;\n    for (var i = 0; i < data.dataset.length; i++) { // avoid division by zero\n      data.dataset[i].leadtime_avg = [];\n      for (var j = 0; j < data.dataset[i].leadtime_sums.length; j++)\n        if (data.dataset[i].leadtime_sums[j] && data.dataset[i].counters[j])\n          data.dataset[i].leadtime_avg.push(data.dataset[i].leadtime_sums[j] / data.dataset[i].counters[j] / aDay);\n        else\n          data.dataset[i].leadtime_avg.push(0);\n    }\n    // compute sum of each value\n    for (var i = 0; i < data.dataset.length; i++) {\n      data.dataset[i].count = data.dataset[i].counters.reduce((accumulator, currentValue) => accumulator + currentValue);\n    }\n    // sort the dataset by count, largest first\n\n    data.dataset.sort(function (a, b) {\n      return b.count - a.count;\n    });\n\n    // when using an xasis of type 'time', the dataset is an array of array. The first value of each array is the timestamp followed by\n    // all the values (one per linechart). The timestamp can be in ms, or ISO string (and other formats)\n    var chartdata = [];\n    var maxchart = Math.min(50, data.MAX_NUMBER_OF_VALUES_DISPLAYED, data.dataset.length);\n\n    for (var i = 0; i < data.timeScale.length; i++) {\n      chartdata.push([data.timeScale[i]]);\n      for (var j = 0; j < maxchart; j++)\n        chartdata[i].push(data.dataset[j].leadtime_avg[i]);\n    }\n\n    // setting the dimensions of the data\n    var dimensions = ['timestamp'];\n    for (var i = 0; i < maxchart; i++)\n      dimensions.push(data.dataset[i].value);\n\n\n    // setting the series for the chart\n    var series = [];\n    for (var i = 0; i < maxchart; i++) {\n      series.push(\n        {\n          name: data.dataset[i].value,\n          type: 'line',\n          encode: {\n            x: 'timestamp',\n            y: data.dataset[i].value,\n          }\n        }\n      );\n    }\n    //console.log(data);\n\n\n    var div = document.getElementById(context.scope.widgetId + '_div');\n\n    if (div) {\n      var myChart = echarts.getInstanceByDom(div);\n\n      var maxInterval;\n      switch (data.TIME_LABEL_UNIT){\n        case 'year': maxInterval = 365 * 3600 * 1000 * 24; break;\n        case 'month': maxInterval = 30 * 3600 * 1000 * 24; break;\n        case 'week': maxInterval = 7 * 3600 * 1000 * 24; break;\n        case 'day': maxInterval = 3600 * 1000 * 24; break;\n      }\n      var option = {\n        xAxis: {\n          type: 'time',\n          boundaryGap: false,\n          maxInterval: maxInterval,\n          axisLabel: { rotate: 50, interval: 0 },\n        },\n        yAxis: {\n          type: 'value',\n          name: 'avg leadtime (days)'\n        },\n        dataset: {\n          source: chartdata,\n          dimensions: dimensions,\n        },\n        series: series,\n          title: {\n          text: 'Avg leadtime for top ' + data.MAX_NUMBER_OF_VALUES_DISPLAYED + ' values of ' + data.DIMENSION + ' grouped by ' + data.GROUPBY,\n          bottom: 10,\n          left: 'center'\n        },\n        tooltip: {\n          trigger: 'axis',\n          formatter: tooltipFormatter\n        },\n        legend: {\n          show: true,\n        }\n      };\n\n\n      myChart.setOption(option);\n    }\n  },\n\n  resize: function (size, context) {\n    var div = document.getElementById(context.scope.widgetId + '_div');\n\n    if (div) {\n      var myChart = echarts.getInstanceByDom(div);\n      myChart.resize(\n        {\n          height: size.height,\n          width: size.width\n        });\n\n    }\n  }\n};","style.css":"*{\n\tcolor:#333;\n}"}}
