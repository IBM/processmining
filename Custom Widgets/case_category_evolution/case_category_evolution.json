{"id":null,"name":"case_category_evolution","description":"Displays the evolution of cases according to a DIMENSION or a CUSTOM METRIC. The dimension or custom metric must be mapped as a text (a category). For each value of the dimension, the widget displays the average leadtime of the cases in this category, and the number of cases. Cases can be grouped by day, week, month, or year.","version":"1.0.0","author":"Patrick Megard","inputSchema":[{"name":"DIMENSION","type":"dimension","description":"Select a dimension or custom metric. The dimension must be mapped as a string"},{"name":"ACTIVITY","type":"string","description":"ACTIVITY that holds the dimension value and the timestamp. Enter an activity name or PROCESS if this is the first activity"},{"name":"GROUPBY","type":"string","description":"GROUPBY : day, week, month, year"},{"name":"KEEP_EMPTY_VALUES","type":"string","description":"KEEP_EMPTY_VALUES: \"y\" to keep cases with empty values, \"n\" to exclude these cases"},{"name":"MAX_NUMBER_OF_VALUES_DISPLAYED","type":"string","description":"MAX_NUMBER_OF_VALUES_DISPLAYED:max number of values charted (<=50)"},{"name":"TIME_LABEL_UNIT","type":"string","description":"TIME_LABEL_UNIT: day, week, month, year"},{"name":"DISPLAY_LEGEND","type":"string","description":"DISPLAY_LEGEND: \"y\" or \"n\" to display the chart legend"}],"files":{"view.html":"","backend.js":"(function () {\n\n\n    function filterAndComputeMetrics(trace) {\n        // Use this metrics variable for your own metrics (add more if needed)\n        var metrics = {\n            'exclude': 0,\n            'value': 0,\n            'eventTime': 0,\n            'leadtime': 0\n        };\n\n        var firstevent = trace.get(0).getStartTime();\n        var lastevent = firstevent;\n        if (CUSTOM_METRIC) {\n            metrics.value = API.getCustomMetricValue(CUSTOM_METRIC, trace);\n            if (metrics.value == null) {\n                metrics.exclude = 1;\n                return metrics;\n            }\n        }\n        // Compute the leadtime, get the starttime of ACTIVITY, get DIMENSION value\n        for (var k = 0; k < trace.size(); k++) {\n            var event = trace.get(k);\n            // needed to compute the leadtime\n            if (event.getStartTime() < firstevent) {\n                firstevent = event.getStartTime();\n            }\n            else if (event.getStartTime() > lastevent)\n                lastevent = event.getStartTime();\n\n            // select the start time we want to use for the trend\n            // in case of DIMENSION, get the value from a specific ACTIVITY \n            // if ACTIVITY=='PROCESS' we take the starttime of the process\n            if (ACTIVITY == 'PROCESS' && k==0) {\n                metrics.eventTime = event.getStartTime();\n                if (DIMENSION) // get the DIMENSION value from the first event\n                    metrics.value = event.getStringCustomAttributeValue(DIMENSION);\n            }\n            else if (event.getEventClass() == ACTIVITY) {\n                metrics.eventTime = event.getStartTime();\n                if (DIMENSION) // get the DIMENSION value from this event\n                    metrics.value = event.getStringCustomAttributeValue(DIMENSION);\n            }\n        }\n        if (metrics.value == '') {\n            if (KEEP_EMPTY_VALUES[0] == 'n') { // exclude cases with no value for DIMENSION\n                metrics.exclude = 1;\n            }\n            else { // keep the case and replace the value with None\n                metrics.value = \"None\";\n            }\n        }\n        metrics.leadtime = lastevent - firstevent;\n        if (metrics.eventTime == 0) metrics.exclude = 1; // ACTIVITY NOT FOUND\n        return metrics;\n    }\n\n    function computeScale(groupBy, aDate) {\n        // Update timeScale array, and push new counters to each dataset value\n\n        var newtimeScale = [];\n        var appendCounters = [];\n        aDate.setHours(0, 0, 0, 0);\n        switch (groupBy) {\n            case \"week\": aDate.setDate(aDate.getDate() - aDate.getDay()); break;\n            case \"month\": aDate.setMonth(aDate.getMonth(), 1); break;\n            case \"year\": aDate.setFullYear(aDate.getFullYear(), 0, 1); break;\n        }\n        var eventTime = aDate.getTime();\n\n        if (timeScale.length == 0) { // first event\n            timeScale.push(eventTime);\n        }\n        else if (eventTime < timeScale[0]) { // create new dates array and concat it with previous, until earliestTimePrevious\n            aDate.setTime(eventTime);\n            while (aDate.getTime() < timeScale[0]) {\n                newtimeScale.push(aDate.getTime());\n                switch (groupBy) {\n                    case \"day\": aDate.setDate(aDate.getDate() + 1); break;\n                    case \"week\": aDate.setDate(aDate.getDate() + 7); break;\n                    case \"month\": aDate.setMonth(aDate.getMonth() + 1); break;\n                    case \"year\": aDate.setFullYear(aDate.getFullYear() + 1); break;\n                }\n                appendCounters.push(0);\n            }\n            timeScale = newtimeScale.concat(timeScale);\n            for (k = 0; k < dataset.length; k++) {\n                dataset[k].counters = appendCounters.concat(dataset[k].counters);\n                dataset[k].leadtime_sums = appendCounters.concat(dataset[k].leadtime_sums);\n            }\n        }\n        else if (eventTime > timeScale[timeScale.length - 1]) { // last time was the latest, eventTime is later: add days\n            aDate.setTime(timeScale[timeScale.length - 1]);\n            while (aDate.getTime() < eventTime) {\n                switch (groupBy) {\n                    case \"day\": aDate.setDate(aDate.getDate() + 1); break;\n                    case \"week\": aDate.setDate(aDate.getDate() + 7); break;\n                    case \"month\": aDate.setMonth(aDate.getMonth() + 1); break;\n                    case \"year\": aDate.setFullYear(aDate.getFullYear() + 1); break;\n                }\n                timeScale.push(aDate.getTime());\n                for (k = 0; k < dataset.length; k++) {\n                    dataset[k].counters.push(0); // add 0 for each new date, to each counter array\n                    dataset[k].leadtime_sums.push(0); // add 0 for each new date, to each counter array\n                }\n            }\n        }\n        return eventTime;\n    }\n\n    return {\n        init: function (params) {\n            var groupByChoices = ['day', 'week', 'month', 'year'];\n            CUSTOM_METRIC = 0;\n            DIMENSION = 0;\n            // Is the selected dimension a standard dimension or a custom metric? Check the name\n            if (params.DIMENSION.indexOf('attr-custom-metrics') >= 0)\n                CUSTOM_METRIC = params.DIMENSION.replace('attr-custom-metrics', '');\n            else if (params.DIMENSION.indexOf('attr-custom-') >= 0)\n                DIMENSION = params.DIMENSION.replace('attr-custom-', '');\n\n            // Which date to use: PROCESS or ACTIVITY_NAME\n            // Which time to use: STARTTIME, ENDTIME\n            GROUPBY = params.GROUPBY;\n            EVENT_TIME = params.EVENT_TIME; // can be 'STARTTIME' or 'ENDTIME'\n            var groupByIndex = groupByChoices.indexOf(GROUPBY);\n            if (groupByIndex < 0){\n                GROUPBY = 'month';\n                groupByIndex = groupByChoices.indexOf(GROUPBY);\n            }\n            TIME_LABEL_UNIT = params.TIME_LABEL_UNIT;\n            var time_label_unit_index = groupByChoices.indexOf(TIME_LABEL_UNIT);\n            if (time_label_unit_index < 0){\n                TIME_LABEL_UNIT = 'month';\n                time_label_unit_index = groupByChoices.indexOf(TIME_LABEL_UNIT);\n            } \n            if (time_label_unit_index < groupByIndex)\n                TIME_LABEL_UNIT = groupByChoices[groupByIndex]\n\n            ACTIVITY = params.ACTIVITY; // the activity in which we find the value of the dimension and from which we take the timestamp\n            if (ACTIVITY == '') ACTIVITY = 'PROCESS';\n\n            KEEP_EMPTY_VALUES = params.KEEP_EMPTY_VALUES; // \"yes\"=keep cases when value=='', \"no\"= exclude these cases\n            if (KEEP_EMPTY_VALUES == '') KEEP_EMPTY_VALUES= 'no';\n            else if (KEEP_EMPTY_VALUES[0] == 'y') KEEP_EMPTY_VALUES = 'yes';\n            else KEEP_EMPTY_VALUES = 'no';\n\n            MAX_NUMBER_OF_VALUES_DISPLAYED = params.MAX_NUMBER_OF_VALUES_DISPLAYED; // show top N values (max is hardcoded at 50)\n            if (MAX_NUMBER_OF_VALUES_DISPLAYED == '')\n                MAX_NUMBER_OF_VALUES_DISPLAYED = 50;\n            else\n                MAX_NUMBER_OF_VALUES_DISPLAYED = Math.min(50, Number(MAX_NUMBER_OF_VALUES_DISPLAYED));\n\n            DISPLAY_LEGEND = params.DISPLAY_LEGEND;\n            if (DISPLAY_LEGEND == '') DISPLAY_LEGEND = true;\n            else if (DISPLAY_LEGEND[0] == 'n') DISPLAY_LEGEND = false;\n            else DISPLAY_LEGEND = true;\n\n            timeScale = [];\n            dataset = [];\n            console.log('init() ends');\n\n        },\n\n        update: function (trace) {\n\n            if (trace.getDiscarded == 1) {\n                return;\n            }\n\n            var metrics = filterAndComputeMetrics(trace);\n            if (metrics.exclude)\n                return;\n\n            eventTime = computeScale(GROUPBY, new Date(metrics.eventTime));\n\n            if (dataset.length == 0) { // first event\n                dataset.push({\n                    'value': metrics.value,\n                    'counters': [1],\n                    'leadtime_sums': [metrics.leadtime]\n                });\n                return;\n            }\n\n            // search the index of 'value' in the dataset array\n            var valueindex = -1;\n            for (var k = 0; k < dataset.length; k++) {\n                if (dataset[k].value == metrics.value) {\n                    valueindex = k;\n                    break;\n                }\n            }\n            if (valueindex < 0) {// value not yet added; add it to dataset\n                valueindex = dataset.push({\n                    'value': metrics.value,\n                    'counters': [],\n                    'leadtime_sums': []\n                }) - 1;\n                // update counters\n                for (var ii = 0; ii < dataset[0].counters.length; ii++) {\n                    dataset[valueindex].counters.push(0);\n                    dataset[valueindex].leadtime_sums.push(0);\n                }\n            }\n\n            // update the counters\n            dataset[valueindex].counters[timeScale.indexOf(eventTime)]++;\n            dataset[valueindex].leadtime_sums[timeScale.indexOf(eventTime)] += metrics.leadtime;\n        },\n\n        finalize: function (output) {\n            output.DIMENSION = (DIMENSION ? DIMENSION: CUSTOM_METRIC);\n            output.GROUPBY = GROUPBY;\n            output.TIME_LABEL_UNIT = TIME_LABEL_UNIT;\n            output.MAX_NUMBER_OF_VALUES_DISPLAYED = MAX_NUMBER_OF_VALUES_DISPLAYED;\n            output.ACTIVITY = ACTIVITY;\n            output.TIMESCALE = timeScale;\n            output.DATASET = dataset;\n            output.DISPLAY_LEGEND = DISPLAY_LEGEND;\n            console.log('finalize() done');\n        }\n    };\n})();\n\n","frontend.js":"return {\n\n  init: function (context) {\n    var widget = document.getElementById(context.scope.widgetId);\n    var div = document.createElement('div');\n    div.id = context.scope.widgetId + '_div'; // creates a unique div id\n    widget.appendChild(div);\n    echarts.init(div);\n  },\n\n  update: function (data, context) {\n\n    // get the variables from the backend\n    var DIMENSION = data.DIMENSION;\n    var GROUPBY = data.GROUPBY;\n    var TIME_LABEL_UNIT = data.TIME_LABEL_UNIT;\n    var MAX_NUMBER_OF_VALUES_DISPLAYED = data.MAX_NUMBER_OF_VALUES_DISPLAYED;\n    var ACTIVITY = data.ACTIVITY;\n    var TIMESCALE = data.TIMESCALE;\n    var DATASET = data.DATASET;\n    var DISPLAY_LEGEND = data.DISPLAY_LEGEND;\n\n\n\n    //console.log(data);\n    //compute the average leadtime \n    var aDay = 24 * 60 * 60 * 1000;\n    for (var i = 0; i < DATASET.length; i++) { // avoid division by zero\n      DATASET[i].leadtime_avg = [];\n      for (var j = 0; j < DATASET[i].leadtime_sums.length; j++)\n        if (DATASET[i].leadtime_sums[j] && DATASET[i].counters[j])\n          DATASET[i].leadtime_avg.push(DATASET[i].leadtime_sums[j] / DATASET[i].counters[j] / aDay);\n        else\n          DATASET[i].leadtime_avg.push(0);\n    }\n\n    // compute count of cases for each value of the dimension\n    for (var i = 0; i < DATASET.length; i++) {\n      DATASET[i].count = DATASET[i].counters.reduce((accumulator, currentValue) => accumulator + currentValue);\n    }\n    // sort the dataset by count of cases, largest first\n    DATASET.sort(function (a, b) {\n      return b.count - a.count;\n    });\n\n    //console.log(DATASET);\n    // FORMAT DATASET FOR RENDERING WITH AN AXIS OF TYPE TIME\n    // when using an xasis of type 'time', the dataset is an array of array. The first value of each array is the timestamp followed by\n    // all the values (one per linechart). The timestamp can be in ms, or ISO string (and other formats)\n    var chartdataset = [];\n    var MAX_NUMBER_OF_VALUES_DISPLAYED = Math.min(50, MAX_NUMBER_OF_VALUES_DISPLAYED, DATASET.length);\n\n\n    for (var i = 0; i < TIMESCALE.length; i++) {\n      chartdataset.push([TIMESCALE[i]]);\n      for (var j = 0; j < MAX_NUMBER_OF_VALUES_DISPLAYED; j++)\n        chartdataset[i].push(DATASET[j].leadtime_avg[i]);\n      for (var j = 0; j < MAX_NUMBER_OF_VALUES_DISPLAYED; j++)\n        chartdataset[i].push(DATASET[j].counters[i]);\n    }\n\n    // Set the dimensions of the chart data\n    var dimensions = ['timestamp'];\n    for (var i = 0; i < MAX_NUMBER_OF_VALUES_DISPLAYED; i++)\n      dimensions.push(DATASET[i].value);\n    for (var i = 0; i < MAX_NUMBER_OF_VALUES_DISPLAYED; i++)\n      dimensions.push(DATASET[i].value + ' #cases');\n\n    //console.log(dimensions);\n\n    // set the series for the chart\n    var series = [];\n    // average leadtime\n    for (var i = 0; i < MAX_NUMBER_OF_VALUES_DISPLAYED; i++) {\n      series.push(\n        {\n          name: DATASET[i].value,\n          tooltip: {\n            valueFormatter: (value) => value.toFixed(1)\n          },\n          type: 'line',\n          encode: {\n            x: 'timestamp',\n            y: DATASET[i].value,\n          }\n        }\n      );\n    }\n\n    // volume of cases (count)\n    for (var i = 0; i < MAX_NUMBER_OF_VALUES_DISPLAYED; i++) {\n      series.push(\n        {\n          name: DATASET[i].value + ' #cases',\n          type: 'bar',\n          stack: 'Ad',\n          xAxisIndex: 1,\n          yAxisIndex: 1,\n          encode: {\n            x: 'timestamp',\n            y: DATASET[i].value + ' #cases',\n          }\n        }\n      );\n    }\n    //console.log(series);\n    // console.log(chartdataset);\n    // CHART RENDERING\n\n    // CHART COLORS\n    // we need to limit the size of colors to the size of MAX_NUMBER_OF_VALUES_DISPLAYED such that the line chart \n    // and bar chart share the same color for each value\n    var colors = ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'];\n    colors = colors.slice(0, MAX_NUMBER_OF_VALUES_DISPLAYED);\n\n    // TOOLTIP\n    // OPTIONAL: refactor the tooltip entirely\n    // That is useful to format the date, or to regroup the datasets (count and leadtime in the same row)\n    function tooltipFormatter(params) {\n      // see what params looks like in the console. It is an array, one entry per linechart. The dataset is the same in each array params[i].data\n      // console.log(params);\n      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n      var aDate = new Date(parseInt(params[0].axisValue));\n      var tooltip;\n      switch (GROUPBY) {\n        case 'day': tooltip = aDate.toDateString() + '<br />'; break;\n        case 'week': tooltip = 'Week ' + aDate.toDateString() + '<br />'; break;\n        case 'month': tooltip = aDate.getFullYear().toString() + '-' + months[aDate.getUTCMonth()] + '<br />'; break;\n        case 'year': tooltip = aDate.getFullYear().toString() + '<br />'; break;\n      }\n      // params is an array of arrays. one for each chart\n      // data[0] is the timestamp, marker is different in each params[i]\n      // regroup each chart (leadtime, #cases) in a single line\n      for (var i = 0; i < params.length / 2; i++) {\n        tooltip += params[i].marker + ' ' + params[i].dimensionNames[i + 1] + ': ' + params[i].data[i + 1 + (params.length / 2)] + ' cases, ' + params[i].data[i + 1].toFixed(1) + ' days' + '<br />';\n      }\n      return tooltip;\n    };\n\n    var tooltip = {\n      trigger: 'axis',\n      formatter: tooltipFormatter,\n      borderWidth: 1,\n      borderColor: '#ccc',\n      padding: 10,\n      textStyle: {\n        color: '#000'\n      },\n      // OPTIONNALY POSITION THE TOOL\n      /*\n      position: function (pos, params, el, elRect, size) {\n        const obj = {\n          top: 10\n        };\n        obj[['left', 'right'][+(pos[0] < size.viewSize[0] / 2)]] = 30;\n        return obj;\n      }*/\n    };\n\n    // customize the legend to have only 1 line per DIMENSION value\n    var legend_data = [];\n    for (var i = 0; i < MAX_NUMBER_OF_VALUES_DISPLAYED; i++) {\n      legend_data.push(\n        {\n          name: series[i].name,\n          icon: 'square',\n        }\n      );\n    }\n\n    // Maximal interval between x ticks depends on TIME_LABEL_UNIT\n    var max_x_tick_interval;\n    switch (TIME_LABEL_UNIT){\n      case 'year': max_x_tick_interval = 365*24*3600*1000; break;\n      case 'month': max_x_tick_interval = 30*24*3600*1000; break;\n      case 'week' : max_x_tick_interval = 7*24*3600*1000; break;\n      case 'day' : max_x_tick_interval = 7*24*3600*1000; break;\n    }\n\n    \n    var option = {\n      series: series,\n      dataset: {\n        source: chartdataset,\n        dimensions: dimensions,\n      },\n      title: {\n        text: DIMENSION + ' values',\n        left: 'center'\n      },\n      color: colors,\n      axisPointer: {\n        link: [\n          {\n            xAxisIndex: 'all'\n          }\n        ],\n        label: {\n          backgroundColor: '#777'\n        }\n      },\n\n      grid: [\n        {\n          left: '8%',\n          top: '8%',\n          width: '90%',\n          height: '50%'\n        },\n        {\n          left: '8%',\n          bottom: '8%',\n          width: '90%',\n          height: '20%'\n        }\n      ],\n\n      yAxis: [\n        {\n          scale: true,\n          name: 'Avg leadtime (d)',\n          splitArea: {\n            show: true\n          }\n        },\n\n        {\n          scale: true,\n          name: '# cases',\n          gridIndex: 1,\n          splitNumber: 2,\n          //axisLabel: { show: false },\n          //axisLine: { show: false },\n          //axisTick: { show: false },\n          //splitLine: { show: false }\n        }\n      ],\n      xAxis: [\n        {\n          type: 'time',\n          boundaryGap: false,\n\n          axisLine: { onZero: false },\n          splitLine: { show: false },\n          min: 'dataMin',\n          max: 'dataMax',\n          maxInterval: max_x_tick_interval,\n          axisPointer: {\n            z: 100\n          }\n        },\n        {\n          type: 'time',\n          gridIndex: 1,\n          boundaryGap: false,\n          axisLine: { onZero: false },\n          axisTick: { show: false },\n          splitLine: { show: false },\n          axisLabel: { show: false },\n          min: 'dataMin',\n          max: 'dataMax'\n        }\n      ],\n      legend: {\n        show: DISPLAY_LEGEND,\n        bottom: '5',\n        left: '5',\n        orient: 'horizontal',\n        data: legend_data\n      },\n      tooltip: tooltip\n    };\n\n    var div = document.getElementById(context.scope.widgetId + '_div');\n\n    if (div) {\n      // retrieve the chart created in init()\n      var myChart = echarts.getInstanceByDom(div);\n      myChart.setOption(option);\n    }\n  },\n\n  resize: function (size, context) {\n    var div = document.getElementById(context.scope.widgetId + '_div');\n\n    if (div) {\n      var myChart = echarts.getInstanceByDom(div);\n      myChart.resize(\n        {\n          height: size.height,\n          width: size.width\n        });\n    }\n  }\n};","style.css":"*{\n\tcolor:#333;\n}\n\n\nh1{\n    font-weight: 500;\n    margin: 0;\n  \tfont-size: 1rem;\n\tpadding-bottom: 0.2rem;\n}\n\nh2{\n    font-size: 1rem;\n    margin: 0px;\n    font-weight: 400;\n}\n\n\np{\n  margin: 0px;\n}\n\n.kyp-wrapper{\n    display: flex;\n    flex-direction: row;\n    gap: 0.5rem;\n    align-items: center;\n    padding: 0.5rem;\n    flex-wrap: wrap;\n    justify-content: center;\n}\n\n.kpi-card{\n    text-align: center;\n    display: flex;\n    flex-direction: column;\n    gap: 0.2rem;\n    align-items: center;\n    box-shadow: 0px 1px 7px -4px #00000078;\n    border-radius: 0.2rem;\n    padding: 0.5rem;\n}\n\n.main-grid{\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    align-items: center;\n    padding: 1rem;\n    flex-wrap: wrap;\n    justify-content: center;\n}"}}
